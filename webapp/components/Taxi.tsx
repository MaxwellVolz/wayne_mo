/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/models/taxi.glb --output components/Taxi.tsx --types --keepgroups --keepnames --meta
Modified: Added movement logic and default export
*/

import * as THREE from 'three'
import React, { useRef } from 'react'
import { useGLTF } from '@react-three/drei'
import { useFrame } from '@react-three/fiber'
import { GLTF } from 'three-stdlib'
import type { Taxi as TaxiType } from '@/types/game'
import { updateTaxi, samplePath } from '@/lib/movement'
import { getTimeScale } from '@/lib/gameState'
import { getIntersections } from '@/lib/intersectionState'
import { getAssetPath } from '@/lib/assetPath'

type GLTFResult = GLTF & {
  nodes: {
    taxi: THREE.Mesh
  }
  materials: {
    ['colormap.013']: THREE.MeshStandardMaterial
  }
}

// Static model export (for reuse)
export function Model(props: React.ComponentProps<'group'>) {
  const { nodes, materials } = useGLTF(getAssetPath('models/taxi.glb')) as unknown as GLTFResult
  return (
    <group {...props} dispose={null}>
      <group name="Scene">
        <mesh name="taxi" geometry={nodes.taxi.geometry} material={materials['colormap.013']} rotation={[Math.PI / 2, 0, 0]} scale={0.297} userData={{ name: 'taxi' }} />
      </group>
    </group>
  )
}

// Game taxi with movement logic (default export)
interface TaxiProps {
  taxi: TaxiType
  isPaused: boolean
  deliveryColor?: string
}

export default function Taxi({ taxi, isPaused, deliveryColor }: TaxiProps) {
  const groupRef = useRef<THREE.Group>(null)
  const meshRef = useRef<THREE.Mesh>(null)
  const previousPosition = useRef<THREE.Vector3>(new THREE.Vector3())
  const spawnTime = useRef<number>(Date.now())
  const { nodes, materials } = useGLTF(getAssetPath('models/taxi.glb')) as unknown as GLTFResult

  // Initialize position immediately to avoid flash at origin
  const initialPosition = React.useMemo(() => {
    if (taxi.path) {
      return samplePath(taxi.path, taxi.t)
    }
    return new THREE.Vector3(0, -1000, 0) // Hide far below if no path
  }, []) // Only run once on mount

  // Use Three.js render loop for smooth animation
  useFrame((state, delta) => {
    if (!groupRef.current || !taxi.path) return

    // Fade in from 0 to 100% opacity over 0.5 seconds
    const elapsedTime = (Date.now() - spawnTime.current) / 1000
    const FADE_DURATION = 0.5
    const opacity = Math.min(elapsedTime / FADE_DURATION, 1)

    // Update material opacity directly
    if (meshRef.current && meshRef.current.material instanceof THREE.Material) {
      (meshRef.current.material as THREE.MeshStandardMaterial).opacity = opacity
    }

    // Don't update movement when paused
    if (isPaused) return

    // Apply time scale for slow-motion
    const timeScale = getTimeScale()
    const scaledDelta = delta * timeScale

    // Update taxi position along path (with intersection routing)
    const intersections = getIntersections()
    updateTaxi(taxi, scaledDelta, intersections)

    // Sample new position from path
    const position = samplePath(taxi.path, taxi.t)
    groupRef.current.position.copy(position)

    // Calculate rotation to face movement direction
    if (!previousPosition.current.equals(position)) {
      const direction = new THREE.Vector3()
        .subVectors(position, previousPosition.current)
        .normalize()

      if (direction.length() > 0.01) {
        const angle = Math.atan2(direction.x, direction.z)
        groupRef.current.rotation.y = angle
      }
    }

    previousPosition.current.copy(position)
  })

  // Emissive color based on state (for status indication)
  const getEmissiveColor = () => {
    switch (taxi.state) {
      case 'stopped':
        return '#ff0000' // Red glow when stopped
      case 'needs_service':
        return '#ff8800' // Orange glow needs service
      case 'broken':
        return '#440000' // Dark red glow when broken
      default:
        return '#000000' // No glow normally
    }
  }

  return (
    <group ref={groupRef} position={initialPosition}>
      <mesh
        ref={meshRef}
        geometry={nodes.taxi.geometry}
        material={materials['colormap.013']}
        rotation={[Math.PI / 2, 0, 0]}
        scale={0.297}
        castShadow
        renderOrder={10}
      >
        {/* Clone material and add emissive for state indication + fade-in */}
        <meshStandardMaterial
          {...materials['colormap.013']}
          emissive={getEmissiveColor()}
          emissiveIntensity={0.5}
          transparent={true}
          opacity={0}
        />
      </mesh>

      {/* Colored rectangle underglow when carrying a package */}
      {taxi.hasPackage && deliveryColor && (
        <>
          {/* <mesh position={[0, 0.05, 0]}>
            <boxGeometry args={[0.5, 0.05, 0.9]} />
            <meshBasicMaterial
              color={deliveryColor}
              transparent
              opacity={0.8}
            />
          </mesh> */}
          <pointLight
            position={[0, .3, 0]}
            color={deliveryColor}
            intensity={3}
            distance={1}
            decay={3}
          />
        </>
      )}
    </group>
  )
}

useGLTF.preload(getAssetPath('models/taxi.glb'))
