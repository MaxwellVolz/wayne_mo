/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/models/taxi.glb --output components/Taxi.tsx --types --keepgroups --keepnames --meta
Modified: Added movement logic and default export
*/

import * as THREE from 'three'
import React, { useRef } from 'react'
import { useGLTF } from '@react-three/drei'
import { useFrame } from '@react-three/fiber'
import { GLTF } from 'three-stdlib'
import type { Taxi as TaxiType } from '@/types/game'
import { updateTaxi, samplePath } from '@/lib/movement'
import { getTimeScale } from '@/lib/gameState'
import { getIntersections } from '@/lib/intersectionState'

type GLTFResult = GLTF & {
  nodes: {
    taxi: THREE.Mesh
  }
  materials: {
    colormap: THREE.MeshStandardMaterial
  }
}

// Static model export (for reuse)
export function Model(props: React.ComponentProps<'group'>) {
  const { nodes, materials } = useGLTF('/models/taxi.glb') as unknown as GLTFResult
  return (
    <group {...props} dispose={null}>
      <group name="Scene">
        <mesh name="taxi" geometry={nodes.taxi.geometry} material={materials.colormap} rotation={[Math.PI / 2, 0, 0]} scale={0.198} userData={{ name: 'taxi' }} />
      </group>
    </group>
  )
}

// Game taxi with movement logic (default export)
interface TaxiProps {
  taxi: TaxiType
}

export default function Taxi({ taxi }: TaxiProps) {
  const groupRef = useRef<THREE.Group>(null)
  const previousPosition = useRef<THREE.Vector3>(new THREE.Vector3())
  const { nodes, materials } = useGLTF('/models/taxi.glb') as unknown as GLTFResult

  // Use Three.js render loop for smooth animation
  useFrame((state, delta) => {
    if (!groupRef.current || !taxi.path) return

    // Apply time scale for slow-motion
    const timeScale = getTimeScale()
    const scaledDelta = delta * timeScale

    // Update taxi position along path (with intersection routing)
    const intersections = getIntersections()
    updateTaxi(taxi, scaledDelta, intersections)

    // Sample new position from path
    const position = samplePath(taxi.path, taxi.t)
    groupRef.current.position.copy(position)

    // Calculate rotation to face movement direction
    if (!previousPosition.current.equals(position)) {
      const direction = new THREE.Vector3()
        .subVectors(position, previousPosition.current)
        .normalize()

      if (direction.length() > 0.01) {
        const angle = Math.atan2(direction.x, direction.z)
        groupRef.current.rotation.y = angle
      }
    }

    previousPosition.current.copy(position)
  })

  // Emissive color based on state (for status indication)
  const getEmissiveColor = () => {
    switch (taxi.state) {
      case 'stopped':
        return '#ff0000' // Red glow when stopped
      case 'needs_service':
        return '#ff8800' // Orange glow needs service
      case 'broken':
        return '#440000' // Dark red glow when broken
      default:
        return '#000000' // No glow normally
    }
  }

  return (
    <group ref={groupRef}>
      <mesh
        geometry={nodes.taxi.geometry}
        material={materials.colormap}
        rotation={[Math.PI / 2, 0, 0]}
        scale={0.198}
        castShadow
      >
        {/* Clone material and add emissive for state indication */}
        <meshStandardMaterial
          {...materials.colormap}
          emissive={getEmissiveColor()}
          emissiveIntensity={0.5}
        />
      </mesh>
    </group>
  )
}

useGLTF.preload('/models/taxi.glb')
