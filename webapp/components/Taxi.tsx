/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/models/taxi.glb --output components/Taxi.tsx --types --keepgroups --keepnames --meta
Modified: Added movement logic and default export
*/

import * as THREE from 'three'
import React, { useRef } from 'react'
import { useGLTF } from '@react-three/drei'
import { useFrame } from '@react-three/fiber'
import { GLTF } from 'three-stdlib'
import type { Taxi as TaxiType } from '@/types/game'
import { updateTaxi, samplePath } from '@/lib/movement'
import { getTimeScale } from '@/lib/gameState'
import { getIntersections } from '@/lib/intersectionState'
import { getAssetPath } from '@/lib/assetPath'

type GLTFResult = GLTF & {
  nodes: {
    Scene148: THREE.Mesh
    Scene148_1: THREE.Mesh
    Scene148_2: THREE.Mesh
  }
  materials: {
    Synty_Palette_A: THREE.MeshStandardMaterial
    Glass_01: THREE.MeshStandardMaterial
    ['PolygonCity_01_A.006']: THREE.MeshStandardMaterial
  }
}

// Static model export (for reuse)
export function Model(props: React.ComponentProps<'group'>) {
  const { nodes, materials } = useGLTF(getAssetPath('models/taxi.glb')) as unknown as GLTFResult
  return (
    <group {...props} dispose={null}>
      <group name="taxi_cab">
        <mesh name="Scene148" geometry={nodes.Scene148.geometry} material={materials.Synty_Palette_A} />
        <mesh name="Scene148_1" geometry={nodes.Scene148_1.geometry} material={materials.Glass_01} />
        <mesh name="Scene148_2" geometry={nodes.Scene148_2.geometry} material={materials['PolygonCity_01_A.006']} />
      </group>
    </group>
  )
}

// Game taxi with movement logic (default export)
interface TaxiProps {
  taxi: TaxiType
  isPaused: boolean
  deliveryColor?: string
}

export default function Taxi({ taxi, isPaused, deliveryColor }: TaxiProps) {
  const groupRef = useRef<THREE.Group>(null)
  const meshRef = useRef<THREE.Mesh>(null)
  const glassMeshRef = useRef<THREE.Mesh>(null)
  const detailMeshRef = useRef<THREE.Mesh>(null)
  const previousPosition = useRef<THREE.Vector3>(new THREE.Vector3())
  const spawnTime = useRef<number>(Date.now())
  const { nodes, materials } = useGLTF(getAssetPath('models/taxi.glb')) as unknown as GLTFResult

  // Initialize position immediately to avoid flash at origin
  const initialPosition = React.useMemo(() => {
    if (taxi.path) {
      return samplePath(taxi.path, taxi.t)
    }
    return new THREE.Vector3(0, -1000, 0) // Hide far below if no path
  }, []) // Only run once on mount

  // Use Three.js render loop for smooth animation
  useFrame((state, delta) => {
    if (!groupRef.current || !taxi.path) return

    // Fade in from 0 to 100% opacity over 0.5 seconds
    const elapsedTime = (Date.now() - spawnTime.current) / 1000
    const FADE_DURATION = 0.5
    const opacity = Math.min(elapsedTime / FADE_DURATION, 1)

    // Update material opacity for all meshes
    const updateMeshOpacity = (mesh: THREE.Mesh | null) => {
      if (mesh?.material instanceof THREE.Material) {
        (mesh.material as THREE.MeshStandardMaterial).opacity = opacity
      }
    }
    updateMeshOpacity(meshRef.current)
    updateMeshOpacity(glassMeshRef.current)
    updateMeshOpacity(detailMeshRef.current)

    // Don't update movement when paused
    if (isPaused) return

    // Apply time scale for slow-motion
    const timeScale = getTimeScale()
    const scaledDelta = delta * timeScale

    // Update taxi position along path (with intersection routing)
    const intersections = getIntersections()
    updateTaxi(taxi, scaledDelta, intersections)

    // Sample new position from path
    const position = samplePath(taxi.path, taxi.t)
    groupRef.current.position.copy(position)

    // Calculate rotation to face movement direction
    if (!previousPosition.current.equals(position)) {
      const direction = new THREE.Vector3()
        .subVectors(position, previousPosition.current)
        .normalize()

      if (direction.length() > 0.01) {
        const angle = Math.atan2(direction.x, direction.z)
        groupRef.current.rotation.y = angle
      }
    }

    previousPosition.current.copy(position)
  })

  // Emissive color based on state (for status indication)
  const getEmissiveColor = () => {
    switch (taxi.state) {
      case 'stopped':
        return '#ff0000' // Red glow when stopped
      case 'needs_service':
        return '#ff8800' // Orange glow needs service
      case 'broken':
        return '#440000' // Dark red glow when broken
      default:
        return '#000000' // No glow normally
    }
  }

  return (
    <group ref={groupRef} position={initialPosition}>
      <group name="taxi_cab">
        {/* Main body mesh */}
        <mesh
          ref={meshRef}
          geometry={nodes.Scene148.geometry}
          castShadow
          renderOrder={10}
        >
          <meshStandardMaterial
            {...materials.Synty_Palette_A}
            emissive={getEmissiveColor()}
            emissiveIntensity={0.5}
            transparent={true}
            opacity={0}
          />
        </mesh>
        {/* Glass mesh */}
        <mesh ref={glassMeshRef} geometry={nodes.Scene148_1.geometry}>
          <meshStandardMaterial
            {...materials.Glass_01}
            transparent={true}
            opacity={0}
          />
        </mesh>
        {/* Additional details mesh */}
        <mesh ref={detailMeshRef} geometry={nodes.Scene148_2.geometry}>
          <meshStandardMaterial
            {...materials['PolygonCity_01_A.006']}
            emissive={getEmissiveColor()}
            emissiveIntensity={0.5}
            transparent={true}
            opacity={0}
          />
        </mesh>
      </group>

      {/* Colored rectangle underglow when carrying a package */}
      {taxi.hasPackage && deliveryColor && (
        <pointLight
          position={[0, 0.3, 0]}
          color={deliveryColor}
          intensity={3}
          distance={1}
          decay={3}
        />
      )}
    </group>
  )
}

useGLTF.preload(getAssetPath('models/taxi.glb'))
